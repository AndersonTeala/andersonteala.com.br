[{"content":"Explorando Pesquisa em Largura (Breadth-First Search) com Go: Encontrando Vendedores Às vezes realizamos uma simples tentativa “achamos que é uma tratativa simples” definimos um array para receber uma quantidade de informações como por exemplo nomes. Até aqui tudo bem, queremos pesquisar um nome e encontrar ele no array, mas será que realmente algum dia paramos e pensamos qual é a abordagem correta ?\nFala ai pessoal beleza, aqui é o Teala! E estou aqui para compartilhar com vocês um pouco do meu conhecimento sobre algoritmos. Hoje vamos falar sobre Pesquisa em Largura (Breadth-First Search).\nNas minhas aventuras de estudos sobre algoritmos, estou atualmente realizando a leitura de um livro chamado Entendendo algoritmos. Neste livro o autor Aditya Y. Bhargava aborda diversos assuntos sobre algoritmos, e um deles é a Pesquisa em Largura (Breadth-First Search).\nO que é Pesquisa em Largura (Breadth-First Search) ? Vamos lá. É uma técnica utilizada em algoritmos de grafos para realizar a busca de um vértice inicial até um vértice final. A Pesquisa em Largura conhecida como (Breadth-First Search) é basicamente utilizar uma fila para realizar uma busca, ou seja, o primeiro elemento a entrar na fila é o primeiro a sair.\nComo funciona a Pesquisa em Largura (Breadth-First Search) ? A Pesquisa começa a partir de um vértice inicial, e a partir dele explora todos os seus vizinhos antes de mover para os vizinhos dos vizinhos. Em outras palavras, a Pesquisa em Largura (Breadth-First Search) explora os vértices mais próximos antes de explorar os vértices mais distantes. Realmente sempre verificando o primeiro elemento da fila.\nVamos imaginar o seguinte, que você mora em um condomínio (onde existe outros condomínios ao lado também), e você quer saber se algum dos seus vizinhos são vendedores de sorvetes (Estou dando um exemplo bem simples com sorvete para simplificar o entendimento, e por que também estamos em um calor de 40 graus aqui). Então você monta uma lista com todos os seus vizinhos e passa a bater na porta de cada um deles (estou imaginando essa cena), perguntando a cada vizinho um a um se ele é vendedor de sorvete, se caso ele não vende sorvete você risca o nome dele do topo da lista e coloca no final da lista todos os vizinhos do seu vizinho que você acabou de bater na porta dele e passa a bater na porta do vizinho da sua lista seguinte, porém sempre lembrando que cada um dos seus vizinhos possui outros vizinhos, e que cada vizinho, possui outros vizinhos, praticamente como em uma rede social, amigos de amigos de amigos de amigos, e assim por diante. Caso você encontre um vizinho que vende sorvete você para de bater na porta dos seus vizinhos e vai comprar sorvete com ele. Basicamente é isso que a Pesquisa em Largura (Breadth-First Search) faz.\nVamos para a prática Desenvolvi um pequeno exemplo simples em Go, para que você possa entender melhor como funciona a Pesquisa em Largura (Breadth-First Search). Vou explicar cada trecho de código e disponibilizar o código fonte no final do artigo. Este código em Go gera nomes falsos e verifica se algum desses nomes é um vendedor (\u0026ldquo;salesman\u0026rdquo;).\nImportando as bibliotecas necessárias: No inicio do código utilizo um pacote principal e a importação de três pacotes: fmt para formatação de saída, strings para manipulação de strings e github.com/brianvoe/gofakeit/v6 para geração de dados falsos. package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;github.com/brianvoe/gofakeit/v6\u0026#34; ) Variáveis globais: Declarei duas variáveis globais, myName e initName. var myName string = \u0026#34;Anderson Teala\u0026#34; var initName string = \u0026#34;Me\u0026#34; Função personIsASalesman: Esta função recebe um nome como parâmetro e verifica se as duas primeiras letras do nome formam a string contida em initName. Retorna true se for o caso, indicando que a pessoa é um vendedor. func personIsASalesman(name string) bool { person := string(name[0]) + string(name[1]) if person == initName { return true } else { return false } } Função generateFakeName: Esta função gera uma lista de nomes falsos usando a biblioteca gofakeit e retorna essa lista. func generateFakeName(quantityNames int) []string { fakeNamesMap := []string{myName} gofakeit.Seed(0) for i := 0; i \u0026lt; quantityNames; i++ { fakeNamesMap = append(fakeNamesMap, gofakeit.Name()) } return fakeNamesMap } Função findSeller: Esta função procuro por um vendedor na lista dos nomes falsos. Ela usa a função personIsASalesman para verificar se um nome é de um vendedor. Se encontrar um vendedor, imprime a mensagem indicando o nome e o índice em que foi encontrado. Caso contrário, continua gerando mais nomes falsos. func findSeller(fakeNames []string) bool { verifiedNames := []string{} for index := 0; index \u0026lt; len(fakeNames); index++ { name := fakeNames[index] personHasBeenVerified := strings.Contains(strings.Join(verifiedNames, \u0026#34;,\u0026#34;), name) if !personHasBeenVerified { if personIsASalesman(name) { fmt.Println(\u0026#34;Person: \u0026#34;+name+\u0026#34;, found in the index\u0026#34;, index) return true } else { verifiedNames = append(verifiedNames, name) namesGenerated := generateFakeName(10) fakeNames = append(fakeNames, namesGenerated...) } } } fmt.Println(\u0026#34;verifiedNames\u0026#34;, verifiedNames) return false } Função main: A função main inicia o processo gerando uma lista de 10 nomes falsos e em seguida chama a função findSeller para procurar por um vendedor nesta lista. O resultado é impresso no console. func main() { fakeNames := generateFakeName(10) findSeller(fakeNames) } Conclusão A Pesquisa em Largura (Breadth-First Search) é uma técnica muito útil para encontrar o caminho mais curto entre dois vértices em um grafo. Ela também pode ser usada para encontrar o caminho mais curto em uma árvore, pois uma árvore é um tipo especial de grafo. Você consegue encontrar se existe um caminho de A para B. Se o vendedor de sorvete existir, você encontrará ele no caminho mais curto. Lembre-se que a lista deve ser uma fila, ou seja, o primeiro elemento a entrar na fila é o primeiro a sair. Caso contrário você não encontrará o caminho mais curto. Cada vizinho verificado deve ser retirado e não verificado novamente. Caso contrário você entra em um loop infinito. Referência do livro Entendendo Algoritmos Código fonte Breadth-First Search ","permalink":"https://andersonteala.hamstercode.com.br/posts/breadth-first-search-in-go/","summary":"Explorando Pesquisa em Largura (Breadth-First Search) com Go: Encontrando Vendedores Às vezes realizamos uma simples tentativa “achamos que é uma tratativa simples” definimos um array para receber uma quantidade de informações como por exemplo nomes. Até aqui tudo bem, queremos pesquisar um nome e encontrar ele no array, mas será que realmente algum dia paramos e pensamos qual é a abordagem correta ?\nFala ai pessoal beleza, aqui é o Teala!","title":"Explorando Pesquisa em Largura (Breadth-First Search) com Go: Encontrando Vendedores"},{"content":"Introdução Hoje eu vim escrever um pouco sobre automação de processos no github pois é essencial para melhorar a eficiência e a qualidade do desenvolvimento do seu software.\nOlá pessoal beleza, aqui é o Teala, espero que estejam bem! Hoje eu vim escrever um pouco sobre automação de processos no github pois é essencial para melhorar a eficiência e a qualidade do desenvolvimento do seu software.\nMais antes quero entrar em um outro assunto que, quem nunca subiu um código “Na minha máquina funciona” pois é, essa é a famosa frase quando um amigo iniciante nos envia o link para visualizarmos “localhost:8080” sim senhores eu já vi isso acontecer mais admito nunca fiz isso. Assim como todo mundo eu começei codando sem ter experiência nenhuma e sem saber porra nenhuma mesmo, e está tudo bem foda-se, ninguém nasce sabendo, com isso você irá aprendendo com o dia a dia, com erros e tentativas, mais isso é conversa para outro dia, pois o assunto aqui é outro.\nAntigamente quando começei a codar, eu e um amigo iniciamos um projeto de ecommerce, sim pode dar risada eramos novato que mal saiu das fraudas e queria ir para marte, quem nunca né? Mais o engraçado era que nosso projeto ecommerce era até que interessante, esse realmente nunca saiu do papel, atualmente tenho outros projetos com ele que funcionam e estão em produção, mais esse abandonamos de fato. Só que o engraçado foi que esse projeto ele estava desenvolvendo o backend e eu o frontend (Eu vou tentar encontrar esse projeto e anexo aqui) mais continuando, quando ele me enviou a pasta do backend para testar localmente, foi o máximo, nada funcionava, eu estava em um ambiente linux e ele em um ambiente windows, a pasta onde tinha as imagens estava como “c://home/…..” acreditem estava assim, mais claro, eramos novatos, iriamos saber disso somente depois que percebemos o inevitável, foi somente com o dia a dia quebrando a cara e aprendendo com isso, mais hoje podemos facilmente resolver essa situação com um arquivo .env, docker etc…. (outro assunto para outro dia)\nMesmo resolvendo isso com variaveis de ambiente e um docker-compose, ainda temos ambientes diferentes, e muito diferentes, mais imagino o seguinte, desenvolvendo uma aplicação para importar X arquivo no banco de dados X, onde temos uma série de validações e funções para diversas validações que esperamos que a rotina realize, até mesmo conexão e dependencia de um redis e etc… pois é ao codar lindo e maravilhoso durante a noite inteira nosso código funciona e faz exatamente o que esperamos, mais imagine o seguinte, ao realizar um deploy desse código em produção ou passar para outro dev ele simplementes não funciona e você pensa, caralho fudeo.\nPois é, fudeo mesmo éééé o que que há velhinho????\nIntrodução ao GitHub Actions GitHub Actions, é um poderosa ferramente meus amigos para automação oferencia pelo GitHub que pernite você criar fluxos de trabalho personalizados, para executar ações específicas sempre que ocorrerem eventos em seu repositório, Isso inclui a capacidade de executar testes automaticamente, criar pull requests e muito mais.\nSeu Fluxo de Trabalho A primeira etapa para automatizar seus testes e pull requests é configurar um fluxo de trabalho no seu repositório GitHub. Isso é feito criando um arquivo YAML no diretório .github/workflows do seu repositório. Vamos dar uma olhada em um exemplo de arquivo de configuração:\nname: Test Go code with .env setup, PostgreSQL, and Redis on: push: branches: - main jobs: setup: runs-on: ubuntu-latest steps: # ... Configurações de ambiente e preparação de artefatos ... test: needs: setup runs-on: ubuntu-latest steps: # ... Download de artefatos e execução de testes ... create_pull_request: needs: test runs-on: ubuntu-latest steps: # ... Criação de um pull request após os testes bem-sucedidos ... Passo a Passo Configuração do Ambiente (Setup): Na seção setup, você pode configurar o ambiente necessário para seus testes. Isso pode incluir a inicialização de serviços Docker, a criação de arquivos de configuração ou qualquer outra configuração específica. Execução de Testes (Test): A seção test é onde você executa seus testes. Você pode baixar artefatos gerados na seção de configuração do ambiente, executar seus testes e, se eles passarem, continuar para a próxima etapa. Criação de Pull Request (Create Pull Request): A seção create_pull_request cria um pull request na branch main do seu repositório após os testes terem sido bem-sucedidos. Isso pode ser útil para garantir que apenas código testado e aprovado seja incorporado ao projeto principal. Gerenciando Artefatos Uma parte importante desse processo é o compartilhamento de informações entre as etapas do fluxo de trabalho. Os “artefatos” são uma maneira de armazenar informações que podem ser acessadas entre as etapas. No exemplo acima, usamos a ação actions/upload-artifact para enviar artefatos gerados na etapa de configuração para a etapa de teste.\nConfigurando Segredos Sério isso é muito importante para autenticação e acesso a recursos privados, como repositórios privados do GitHub, é importante configurar segredos em seu repositório. Neste artigo, eu usei secrets.GIT_TOKEN como um exemplo de token de acesso para criar um pull request no GitHub.\nAs Aventuras de CI/CD, o Mestre da Automação “Meus caros, deixem-me contar uma história sobre um dia em que precisei recorrer ao CI/CD, essa arma secreta do mundo da tecnologia. A ocasião era uma missão delicada que envolvia a entrega de um software altamente confidencial. Era como se eu estivesse navegando em águas profundas e perigosas, cercado por tubarões famintos.\nEra uma manhã chuvosa em algum lugar remoto, e eu estava cercado por uma equipe de desenvolvedores que estavam trabalhando incansavelmente para concluir o código de um projeto ultra-secreto. O que tornava tudo ainda mais desafiador era o prazo apertado e a necessidade de manter a operação sob total sigilo.\nFoi nesse momento que eu soube que precisava do CI/CD ao meu lado. O CI/CD era como um aliado silencioso, um agente secreto infiltrado no mundo da automação de software. Ele podia automatizar o processo de construção, teste e implantação, garantindo que nosso software fosse entregue com precisão e eficiência.\nEu me virei para a equipe e disse: “Preparem-se, pois vamos implantar o CI/CD”. Todos sabiam que era um sinal de que estávamos prestes a entrar em território desconhecido. O CI/CD não era uma ferramenta qualquer; ele era como uma máquina bem azeitada, pronta para entrar em ação.\nAssim que acionamos o CI/CD, ele começou a trabalhar sua magia. O código foi verificado, os testes automatizados foram executados e os artefatos foram criados. Era uma visão hipnotizante, observar como o CI/CD coordenava todas as partes móveis sem pestanejar.\nE então veio a parte mais intrigante. O CI/CD orquestrou a implantação do software em nosso ambiente de produção, como um maestro conduzindo uma sinfonia. E o melhor de tudo, ele fez isso sem causar nenhuma interrupção para nossos usuários.\nEnquanto eu observava a operação se desenrolar, não pude deixar de admirar a eficiência do CI/CD. Era como se ele estivesse dançando no limite entre o caos e a ordem, mantendo tudo sob controle.\nAo final da operação, olhei para a equipe e disse: “Missão cumprida”. Graças ao CI/CD, tínhamos entregado nosso software de maneira rápida e eficaz, mantendo nossos segredos seguros.\nE assim, meus caros, essa é a história de como o CI/CD, essa ferramenta mágica da automação, nos ajudou a superar um dos desafios mais difíceis que já enfrentei. Às vezes, na vida do crime, é preciso recorrer às armas mais inesperadas para alcançar o sucesso.”\nConclusão Automatizar testes e a criação de pull requests pode economizar tempo e melhorar a qualidade do seu código. O GitHub Actions oferece uma maneira poderosa de configurar esses processos de automação em seu repositório GitHub. Personalize o fluxo de trabalho de acordo com suas necessidades específicas e aproveite os benefícios da automação.\nEspero que este artigo tenha sido útil para entender como automatizar testes e pull requests com o GitHub Actions. Lembre-se de ajustar as configurações para atender às necessidades do seu projeto e aproveitar ao máximo essa poderosa ferramenta de automação.\nSegue agora uma pequena história sobre CI/CD, porém jamais saberemos se ela é de fato verdadeira.\n","permalink":"https://andersonteala.hamstercode.com.br/posts/automatizando-testes-pull-requests-github-actions/","summary":"Introdução Hoje eu vim escrever um pouco sobre automação de processos no github pois é essencial para melhorar a eficiência e a qualidade do desenvolvimento do seu software.\nOlá pessoal beleza, aqui é o Teala, espero que estejam bem! Hoje eu vim escrever um pouco sobre automação de processos no github pois é essencial para melhorar a eficiência e a qualidade do desenvolvimento do seu software.\nMais antes quero entrar em um outro assunto que, quem nunca subiu um código “Na minha máquina funciona” pois é, essa é a famosa frase quando um amigo iniciante nos envia o link para visualizarmos “localhost:8080” sim senhores eu já vi isso acontecer mais admito nunca fiz isso.","title":"Automatizando Testes e Pull Requests com GitHub Actions"},{"content":"Pesquisa binária Às vezes realizamos uma simples tentativa “achamos que é uma tratativa simples” definimos um array para receber uma quantidade de informações como por exemplo nomes. Até aqui tudo bem, queremos pesquisar um nome e encontrar ele no array, mas será que realmente algum dia paramos e pensamos se esta abordagem é correta ? Se você automaticamente disse que sim parabéns, pare a leitura imediatamente.\nUm tempo atrás quando aprendi a programar que não faz muito tempo, somente 4 anos (sim somente 4 anos, antes disso eu fazia alguns sites em html, css e muito pouco de javascript e acha que programava, mas somente depois que me aprofundei nos estudos percebi que eu não sabia nada e que realmente ainda não sei nada, ainda tem chão muita coisa para se aprender, eu era um tolo em pensar que programava, mas hoje sei e entendo que eu realmente estava mentindo pra mim mesmo), eu vivo me perguntando sobre diversas abordagens sobre “por que isso é feito dessa forma”, “Eu posso melhorar isso de alguma maneira?”, “Realmente não existe outra forma de otimizar essa função?” Se você também vive fazendo essa pergunta, entendo que você apenas quer realmente entender o que acontece debaixo dos panos e mergulhar mais profundamente para resolver essa questão na sua cabeça. Normalmente quando me faço essa pergunta eu viajo em meus pensamos e inicio uma série “Pesquisas sem parar”, fico perdido em assuntos que muitas vezes ficam complexos e complicados, onde preciso até mesmo parar um pouco e continuar depois com a cabeça mais fria e tranquila, pois atualmente em pleno século 21 ano 2023, somos bombardeados de informações pela internet, diante de tanta informação é difícil separar o que realmente é válido e o que não é válido (Esse pensamento eu me refiro a conteúdos de ócio criativo, não navegação em aplicativos como Instagram, Facebook ou qualquer outro feed de rolarem que te transforma em modo zumbi). Isso pra mim é puro lixo.\nEstudando assuntos sobre algoritmos, descobri a pesquisa binária e sinceramente queria eu descobrir isso muito antes (eu ouvia falar, cheguei a ver na faculdade, mais não foi algo que me aprofundei para entender de fato, hoje como decidi ser um melhor programador, estou começando do início, desde o início de fato), uma parada simples mais que ao mesmo tempo é incrível, estou em uma ansiedade tremenda para ir mexer nos meus código pois já consegui pensar em várias situações onde irei usar a pesquisa binária.\nPensando de uma forma simples, se você pergunta a um programador com pouca experiência, o que ele faria em um array com 240K posições, normalmente o mesmo iria dizer fazer um foreach para percorrer o array e encontrar a posição desejada, mas imagina que se a posição de um array fosse exatamente a 240.000, iríamos percorrer o array 240.000 vezes? Claro que não, por esse motivo podemos usar a pesquisa binária que irá salvar a sua vida, mas antes vamos ver uma situação simples.\nNosso array tem 100 posições sendo:\nvar array = [100]int{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100} Imaginamos isso em uma conversa de 2 pessoas, uma irá chutar o número e a segunda vai dizer se está correto, baixo ou alto\nEren: 1 Mikasa: muito baixo Eren: 7 Mikasa: muito baixo Eren: 50 Mikasa: muito baixo Eren: 75 Mikasa: muito alto (Sim os nomes são de personagens de animes, foda-se eu gosto) Nessa conversa simples, sabemos que o numero está dentro de 50 a 75, mais pensando melhor agora que sabemos, eliminamos uma enorme quantidade de busca, e com isso conseguindo fazer o próximo chute com mais precisão, e assim por diante até encontrar o número desejado.\nEren: 63 Mikasa: alto demais Agora que sabemos que o 64 é alto demais, posso fazer o próximo chute, pois está entre o 50 e 64. No caso o valor correto seria 55. Isso é uma pesquisa binária, sendo possível eliminar metade dos números a cada tentativa. Imagina a seguinte situação ao invés de percorrer 100 vezes o array, podemos percorrer somente 7 com a pesquisa binária\nTamanho array = 100 -\u0026gt; 50 -\u0026gt; 25 -\u0026gt; 13 -\u0026gt; 7 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1 Entendeu como é simples, realizamos a busca somente 7 vezes, ao invés de 100 vezes. Agora na situação inicial com o nosso array de 240.000, não precisamos percorrer ele inteiro, somente 18 vezes, teremos um ganho incrível dessa forma. Segue um exemplo utilizando Go:\nPesquisa binária em Go package main import ( \u0026#34;fmt\u0026#34; ) func main() { var array = [100]int{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100} var numero = 55 var inicio = 0 var fim = len(array) - 1 var meio = 0 var achou = false for inicio \u0026lt;= fim { meio = (inicio + fim) / 2 if array[meio] == numero { achou = true break } else { if array[meio] \u0026lt; numero { inicio = meio + 1 } else { fim = meio - 1 } } } if achou { fmt.Println(\u0026#34;O número\u0026#34;, numero, \u0026#34;foi encontrado na posição\u0026#34;, meio) } else { fmt.Println(\u0026#34;O número\u0026#34;, numero, \u0026#34;não foi encontrado\u0026#34;) } } Algoritmo de pesquisa binária Todos os exemplos eu tirei do livro que estou lendo. Segue o link do livro:\nAlgoritmos: Teoria e Prática Bom, esse é o meu primeiro artigo, tentei ser o mais claro possível para que eu consiga visualizar minhas informações no futuro. Tchau!\n","permalink":"https://andersonteala.hamstercode.com.br/posts/pesquisa-binaria/","summary":"Pesquisa binária Às vezes realizamos uma simples tentativa “achamos que é uma tratativa simples” definimos um array para receber uma quantidade de informações como por exemplo nomes. Até aqui tudo bem, queremos pesquisar um nome e encontrar ele no array, mas será que realmente algum dia paramos e pensamos se esta abordagem é correta ? Se você automaticamente disse que sim parabéns, pare a leitura imediatamente.\nUm tempo atrás quando aprendi a programar que não faz muito tempo, somente 4 anos (sim somente 4 anos, antes disso eu fazia alguns sites em html, css e muito pouco de javascript e acha que programava, mas somente depois que me aprofundei nos estudos percebi que eu não sabia nada e que realmente ainda não sei nada, ainda tem chão muita coisa para se aprender, eu era um tolo em pensar que programava, mas hoje sei e entendo que eu realmente estava mentindo pra mim mesmo), eu vivo me perguntando sobre diversas abordagens sobre “por que isso é feito dessa forma”, “Eu posso melhorar isso de alguma maneira?","title":"Pesquisa binária"},{"content":"Estou montando esse blog para compartilhar um pouco do meu conhecimento e experiência que desejo acessar futuramente como uma forma de aprendizado pra mim mesmo e também para que outras pessoas possam se acessar o conteúdo que eu compartilhar aqui.\n","permalink":"https://andersonteala.hamstercode.com.br/posts/hello-for-myself/","summary":"Estou montando esse blog para compartilhar um pouco do meu conhecimento e experiência que desejo acessar futuramente como uma forma de aprendizado pra mim mesmo e também para que outras pessoas possam se acessar o conteúdo que eu compartilhar aqui.","title":"Olá pra mim mesmo!"}]